# StandardWeek
 <details>
<summary>지난 주차들 문제</summary>
<div markdown="1">

## Q1
**[요구사항 1]**

**분석 문제 :** 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- Equipment와 EquipTool 기능의 구조와 핵심 로직을 분석해보세요.
  - Equipment에서는 장착 아이템의 장착, 해제, 공격 시 모션의 기능을 담당한다
    - EquipNew()에선 장착상태를 초기화 한 뒤, ItemData에서 인벤토리에서 장착아이템 장착을 누르면 equipPrefab을 받아와서 Instantiate한다.
    - Uneqip()에선 현재장착아이템curEqip을 Destroy한 다음 curEquip을 null상태로 만든다.
    - OnAttackInput()에선 장착아이템이 존재할 때, 다른 UI활성화가 되지않아서 canlook상태일때, 마우스 입력을 받고있는 상태에서 공격을 가능하게 한다.
  - EquipToll에서는 Equip을 상속받아 공격 시 스태미너 관리, 공격 판정기능을 관리한다.
    - OnAttackInput()에서는 useStamina값에 따라 공격이 나갈 수 있는지를 판단한 뒤 공격 빈도에 따라 공격을 가능하게 한다.
    - OnCanAttack()은 공격이 가능하게끔 초기화하는 로직이다.
    - OnHit()은 조준점을 기준으로 공격 거리길이만큼의 레이캐스트를 쏴서 대상이 자원이라면 자원채취를 가능하게 끔 하는 로직이다
- Resource 기능의 구조와 핵심 로직을 분석해보세요.
    - Gater()는 해당 자원을 채취할 때, capacy(자원 내구도)를 1을 깎고 자원아이템을 드롭한다. capacy가0이하가 되면 더이상 채취할 수 없다.
 
**[요구사항 2]**

**확장 문제 :** 강의 ****내용을 바탕으로 새로운 기능을 추가 구현해봅시다.

- 새로운 자원을 만들고 새로운 자원채취 보상 아이템을 설정해보세요.
- 두 개의 능력치를 사용하는 새로운 무기를 만들고 구현해보세요.

**[요구사항 3]**

**개선 문제** : 기존의 코드를 개선해봅시다. (리팩터링)

---

## Q2
**[요구사항 1]**

**분석 문제** : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- AI 네비게이션 시스템에서 가장 핵심이 되는 개념에 대해 복습해보세요.
  - 가장 핵심이 되는 개념은 NavMesh(Navigation Mesh)입니다. NavMesh는 게임 오브젝트가 이동할 수 있는 경로를 정의하고 AI캐릭터들이 자연스럽고
    효율적으로 경로를 탐색하게 하는 시스템입니다.
    NaveMesh는 AI가 이동할 수 있는 지형을 나타내는 3D 메쉬로, 이 메쉬를 바탕으로 AI가 장애물이나 다양한 지형 요소를 피하면서 목적지로 이동할 수 있게합니다.
  - NavMeshAgent는 AI오브젝트에 부착하는 컴포넌트로, AI오브젝트가 NavMesh 위를 이동하도록 제어하는 컴포넌트입니다. 이 컴포넌트를 통해 AI가 NavMesh의 경로를
    따라 이동하면서, 장애물을 회피하고, 목표지점으로 이동합니다. 이동속도, 회전속도, 가속 등을 조절해 캐릭터의 움직임을 더욱 자연스럽게 만들 수 있습니다.
  - NavMesh Obstacles는 NavMesh위에 존재하는 장애물로, AI가 피해야 하는 요소를 설정하는데 사용됩니다. 이를 통해 AI는 장애물로 인식하고 그 주위를 우회합니다.
  - NavMesh Bake는 NavMesh를 설정하고 빌드하는 과정입니다. 씬에 있는 이동 가능한 영역을 구분하고, AI가 갈 수 있는 길을 네비게이션 메쉬로 정의하는 작업을 의미합니다.
    Bake과정에서 세부적인 옵션을 설정할 수 있습니다(ex. 이동할 수 있는 최대 경서, 이동할 수 없는 작은 틈새설정, 경로탐색 정밀도 등)

- NPC 기능의 구조와 핵심 로직을 분석해보세요.
  - NPC.cs의 기능은 적 NPC의 현재상태 설정을 정의, 이동경로와 범위 설정, 공격상태 설정 및 공격상태 해제 설정, 플레이어 탐색 설정(어그로설정), 사망상태 설정 등이 있습니다.
  - SetState()에서 현재상태 설정을 정의합니다. 현재 기본, 이동, 공격 상태등이 정의되어 있습니다. 동시에 각 상태별 애니메이션의 속도도 초기화합니다.
  - PassiveUpdate()에서는 NPC의 현재상태, 플레이어의 거리에 따라 상태 변화를 다르게 정의합니다.
  - WanderToNewLocation()에서는 상태가 이동상태로 변할때 새로운 이동경로를 탐색하는 로직입니다
  - GetWonderLocation()은 이동상태로 변할때 목표좌표를 얻는 로직입니다.
  - AttackingUpdate()는 플레이어캐릭터와의 좌표거리별로 어떻게 행동하는지 정의하는 로직입니다.
  - IsPlayerInFieldOfView()는 플레이어캐릭터가 적NPC의 탐지범위내에 있는지 확인하고 bool값을 초기화하는 로직입니다.
  - TakePhysicalDamage()는 적NPC가 공격받을 때 데미지 처리 및 데미지 효과를 처리하는 로직입니다.
  - Die()로직은 적NPC가 죽을 때 드롭아이템을 생성하고 적NPC오브젝트를 파괴하는 로직입니다.
  - DamageFlash()는 코루틴으로 적NPC가 데미지를 받을때 해당 오브젝트의 컬러가 변하는 로직입니다.

**[요구사항 2]**

**확장 문제** : 강의 내용을 바탕으로 새로운 기능을 추가 구현해봅시다.

- AI 네비게이션에 대해 학습한 내용을 복습하며 펫 기능을 만들어보세요.
 - 스태미너를 채워주는 펫을 만들었습니다. 범위안으로 플레이어를 인식하면 따라다닙니다.
  
- AI 네비게이션 기능을 바탕으로 원거리 공격 몬스터를 만들어보세요.
(ex. 기존 몬스터보다 추적 범위를 넓히고 원거리에서 무기를 던짐)
 - 원거리 공격 몬스터를 만들었습니다. 
</br>
</br>
### Q3. 숙련 7강, 8강, 17강

**[요구사항 1]**

**분석 문제** : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- 보간에 대해 학습하고 **선형보간(Lerp)**과 **구면선형보간(Slerp)**에 대해 학습해보세요.

  - 보간은 왜 하는 걸까?
  보간은 게임 개발이나 그래픽 프로그래밍에서 두 점 사이를 자연스럽게 연결하는 방법으로, 시각적 효과와 사용 경험을 향상시키기 위해 사용됩니다. 보간을 사용하는 이유는 다음과 같습니다:

1. 부드러운 움직임과 전환 효과
게임 속 객체가 순간이동하거나 급격하게 방향을 바꾸면 부자연스럽게 보입니다. 보간을 통해 움직임을 단계적으로 부드럽게 만들어, 사용자가 자연스러운 경험을 할 수 있도록 합니다.
예를 들어, 캐릭터가 특정 위치로 이동할 때 중간 지점을 여러 번 계산하여 이동하면 이동이 갑작스럽지 않고 서서히 이동하는 효과를 냅니다.
2. 자연스러운 회전
회전도 갑작스럽게 이루어지면 어색하게 보일 수 있습니다. 보간을 통해 회전 각도를 단계적으로 변화시키면, 천천히 한 방향으로 회전하는 느낌을 줄 수 있습니다. 이를 통해 현실적인 물리와 동작을 구현할 수 있으며, 캐릭터나 카메라가 자연스럽게 회전할 수 있습니다.
3. 색상 변화 및 애니메이션 효과
보간은 색상 변화나 다양한 애니메이션에도 사용됩니다. 예를 들어, 버튼을 클릭할 때 색상이 천천히 변하게 하거나, 캐릭터가 데미지를 받을 때 색이 빨간색으로 변했다가 다시 원래 색으로 돌아오는 효과를 주는 것입니다. 이는 시각적으로 더 부드럽고 명확한 피드백을 제공합니다.
4. 게임의 몰입도와 현실감을 향상
게임 내의 움직임, 전환, 효과가 갑작스럽게 이루어지면 사용자에게 어색함을 줄 수 있습니다. 보간을 통해 변화 과정을 부드럽게 연결하면 몰입감을 유지하고 현실감 있는 게임 경험을 제공합니다. 현실 세계에서는 거의 모든 움직임이 시간에 따라 자연스럽게 변화하기 때문에, 이를 모방하는 것이 게임의 질을 높이는 데 매우 중요합니다.
5. 프레임별 계산을 단순화
게임은 각 프레임마다 화면을 갱신하는데, 보간을 사용하면 프레임마다 새 위치나 색상을 정확하게 계산할 수 있어 코드가 더 단순해지고 관리가 쉬워집니다. 보간으로 중간값을 자동으로 계산해주기 때문에, 개발자가 직접 프레임별로 조정하지 않아도 일정한 속도로 변화하는 효과를 구현할 수 있습니다.

  - 선형보간
    - 선형보간은 두 점을 직선으로 연결하여 그 사이의 값을 계산하는 방법입니다. `t`값에 따라 두 점 사이의 위치를 계산합니다.
    - Lerp(a,b,t) = (1-t)*a + t*b
    - 여기서 a는 시작점, b는 끝점 혹은 도착점, t는 0과 1사이의 값(0이 시작점, 1이 도착점)
    - 선형보간의 장점과 한계
      - 장점: 계산이 간단하고 성능이 뛰어나며 직선 상의 보간에 적합합니다.
      - 한계: 회전과 같은 복잡한 보간에는 적합하지 않습니다. 특히, 회전 시 직선 보간으로 인해 결과가 이상하게 보일 수 있습니다.

  - 구면선형보간
    - 구면선형보간은 두 벡터가 이루는 각을 구면(구의 표면)을 따라 보간하는 방법입니다. 보통 회전과 같은 각도를 부드럽게 보간할 때 사용됩니다.
    - 구면선형보간의 장점과 한계
      -장점: 각도를 자연스럽게 보간할 수 있습니다. 회전할 때 발생할 수 있는 왜곡을 방지하며, 카메라나 캐릭터가 특정 방향으로 회전할 때 매우 유용합니다.
      -한계: 계산량이 선형보간보다 많아, 성능에 민감한 곳에서는 주의해야 합니다.

  - 정리 및 사용 시 주의사항
    - Lerp: 두 점 사이를 직선으로 보간하며, 주로 위치 이동이나 단순한 속도 조절에 적합합니다.
    - Slerp: 회전과 같은 각도를 자연스럽게 보간할 때 적합하며, Quaternion을 이용해 회전할 때 많이 사용됩니다.

  - 자료형 사용 예시
    |자료형|	Lerp 적용 예시|	Slerp 적용 예시|
    |:---|:---|:---|
    |Vector3|오브젝트가 직선으로 이동할 때|구면 상에서 자연스럽게 곡선을 따라 이동할 때|
    |Quaternion	|회전을 직선 보간으로 점진적으로 변경할 때	|카메라나 캐릭터의 자연스러운 회전이 필요할 때|
    |Color	|UI 버튼이 색상 변화를 할 때	|지원되지 않음|
    |Float	|단일 값의 변화가 점진적일 때 (투명도, 속도 등)	|지원되지 않음|


- 근사값(`Mathf.Approximately`)을 사용하는 이유에 대해 학습해보세요.
1. 부동 소수점 연산의 정확도 문제
컴퓨터는 소수를 정확히 표현하지 못하는 경우가 많습니다. 예를 들어, 0.1과 같은 소수를 이진법으로 완벽히 나타낼 수 없기 때문에 약간의 오차가 발생합니다. 이로 인해 단순히 == 연산자로 값을 비교하려 하면, 기대한 것과 다른 결과가 나올 수 있습니다.
Mathf.Approximately는 이런 오차를 감안하여, 두 값이 거의 같은지를 확인해 주므로 안정적으로 값 비교를 할 수 있게 합니다.
2. 부드러운 움직임이나 애니메이션 종료 조건에서 사용
게임에서 위치나 회전이 특정 값에 도달했는지 확인할 때 근사 비교가 필요합니다. 예를 들어, 플레이어가 목표 위치에 거의 도달했을 때 이동을 멈추게 하려면, Mathf.Approximately로 확인하면 더 부드러운 결과를 얻을 수 있습니다.
transform.position == targetPosition처럼 비교할 경우, 미세한 부동 소수점 차이로 인해 목표 위치에 정확히 도달하지 못해 멈추지 않거나 이상하게 작동할 수 있습니다. 반면 Mathf.Approximately를 사용하면 이 오차를 무시하고 거의 도달한 경우를 “근사값”으로 인식해 멈추게 할 수 있습니다.
3. 물리 계산과 동작 시 정확성 보장
물리 연산에서 속도나 가속도가 거의 0에 가까울 때 정지 상태로 간주하고 싶을 때, Mathf.Approximately를 사용하면 미세한 소수점 차이를 신경 쓰지 않고 안정적인 정지 상태를 구현할 수 있습니다.
예를 들어, rigidbody.velocity.magnitude == 0으로 비교하려고 하면, 부동 소수점 연산의 미세한 오차로 인해 0이 아닌 아주 작은 값이 남아 무한히 움직이는 상태가 될 수 있습니다. Mathf.Approximately(rigidbody.velocity.magnitude, 0)를 사용하면 근사값으로 처리해 이 문제를 해결할 수 있습니다.
4. UI 및 값의 변화를 다룰 때 활용
UI나 애니메이션에서 부드러운 변화를 주고 싶을 때 Mathf.Approximately는 특히 유용합니다. 예를 들어, 슬라이더 값이 특정 수치에 도달했는지 확인할 때 오차로 인해 값이 정확히 맞지 않아 무한루프에 빠지는 등의 문제가 발생할 수 있습니다.
이 경우 Mathf.Approximately를 사용하면 소수점 차이를 무시하고 슬라이더가 거의 도달했을 때 원하는 동작을 수행하도록 할 수 있습니다.

</br>
</br>
**[요구사항 2]**

**확장 문제** : 강의 내용을 바탕으로 새로운 기능을 추가 구현해봅시다.

- 몬스터가 공격할 때 효과음을 추가해보세요.
  - 추가했는데 애니메이션이랑 사운드가 맞질않습니다.
- 새로운 종류의 조명을 추가해 게임효과를 더해보세요.

  

</div>
</details>



<details>
<summary>이번 주차 문제</summary>
<div markdown="1">

### Q1. 19강 UI 만들기

**확인 문제 : 강의를 듣고, 강의 내용을 다시 점검하는 문제를 풀어봅시다.**

<aside>
🧠 UI의 앵커와 피벗에 대해서 세팅하는 19강의 강의 자료를 다시 확인해보시고, 
아래 퀴즈를 풀어보세요!

</aside>

## Q1

**[🅾️❎퀴즈]**

- 앵커와 피벗은 같은 기능을 한다. (O/X)
  X
  피벗(Pivot)을 중심으로 회전, 크기, 스케일의 수정이 발생한다. UI요소값들의 기준점이 되는 부분이다.
  앵커(Anchor)는 UI요소가 부모 객체(혹은 캔버스)에 대해 어떻게 배치되고 크기가 조정될지 정의하는 기준점이다.
  
- 피벗을 왼쪽 상단으로 설정하면, UI 요소는 화면의 왼쪽 상단을 기준으로 위치가 고정된다. (O/X)

  X 앵커를 왼쪽 상단으로 설정해야 왼쪽 상단 기준으로 위치가 고정된다.

- 피벗을 UI 요소의 중심에 설정하면, 회전 시 UI 요소가 중심을 기준으로 회전한다. (O/X)

  O 피벗은 회전, 크기, 스케일 변경의 기준점입니다.

**[**🤔 **생각해보기]**

- 게임의 상단바와 같이 화면에 특정 영역에 꽉 차게 구성되는 UI와 화면의 특정 영역에 특정한 크기로 등장하는 UI의 앵커 구성이 어떻게 다른 지 설명해보세요.
  - 특정 영역에 꽉 차게 구성되는 UI: 앵커 코너가 특정 영역끝에 설정되어 화면 비율이 변경되어도 그에 맞게 UI크기가 꽉차도록 변할 것입니다.
  - 화면의 특정 영역에 특정한 크기로 등장하는 UI: 앵커 코너들이 특정영역에 설정되어 있어 어떤 방식으로 화면비율, 크기가 바뀌어도 특정영역에 UI가 일정크기를 유지하도록 설정되어 있을 것입니다.
   
- 돌아다니는 몬스터의 HP 바와 늘 고정되어있는 플레이어의 HP바는 Canvas 컴포넌트의 어떤 설정이 달라질 지 생각해보세요.
  - 몬스터의 HP바의 캔버스는 Render Mode가 WorldSpace로 설정되어 몬스터를 따라다니며 렌더링 될 것입니다. 또한 항상 HP바가 플레이어가 볼 수 있게끔 UI가 카메라를 바라보도록 따로 스크립트를 통한 설정이 일어나야합니다.
  또한 캔버스가 너무 커지거나 작아지는 문제를 방지하기위해 Canvas Scaler를 적절히 설정해야 합니다.
  - 플레이어의 HP바의 캔버스는 Rendr Mode가 Overlay나 (카메라효과를 위한)Camera로 설정하여 상시 화면 상에 고정되어 렌더링 되도록 설정되어 있을 것입니다. 
  

**확장 문제 : 강의 내용을 바탕으로 새로운 기능을 추가 구현해봅시다.**

<aside>
⏱️ 게임이 길어지니 힘이 듭니다. 게임을 일시정지하는 버튼을 만들어봅시다.

</aside>

Resume Game이라는 텍스트가 들어있는 버튼을 만들고, 그 버튼을 누르면 게임이 재개되게 하세요.

```cs
// 답안 내역
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class Pause : MonoBehaviour
{
    [SerializeField] private Button resumeBtn;
    private TextMeshProUGUI _resumeText;
    private bool isPaused = false;

    private void Awake()
    {
        InitializeResumeBtn();
    }

    private void Update()
    {
        PauseGame();
    }

    private void InitializeResumeBtn()
    {
        resumeBtn.onClick.AddListener(ResumeGame);
        _resumeText = transform.GetChild(0).GetComponent<TextMeshProUGUI>();
        resumeBtn.gameObject.SetActive(false);
        _resumeText.text = "ResumeButton";
    }

    private void PauseGame()
    {
        if (Input.GetKeyDown(KeyCode.Escape) && !isPaused)
        {
            Time.timeScale = 0f;
            resumeBtn.gameObject.SetActive(true);
            isPaused = true;
        }
    }
    private void ResumeGame()
    {
        Time.timeScale = 1f;
        resumeBtn.gameObject.SetActive(false);
        isPaused = false;
    }
}
```

## Q2

**[🅾️❎퀴즈]**

- 코루틴은 비동기 작업을 처리하기 위해 사용된다. (O/X)

  O 코루틴은 비동기 작업을 처리하기 위해 사용된다. 비동기처럼 보이는 동기작업이다.

- yield return new WaitForSeconds(1);는 코루틴을 1초 동안 대기시킨다. (O/X)

  O 1초동안 대기시 후 다음 코드를 실행하거나 while(true)같은 경우 반복을 시작한다.

- 코루틴은 void를 반환하는 메소드의 형태로 구현된다. (O/X)

  X IEnomrator형태로 반환값을 지정해줘야한다.

**[**🤔 **생각해보기]**

- 코루틴을 이미 실행중이라면 추가로 실행하지 않으려면 어떻게 처리해주면 될까요?
  - 예를 들어, isCoroutineStart과 같은 플래그를 설정한 뒤 코루틴 함수에 진행여부를 파악하고 실행하면 된다.

- 코루틴 실행 중 게임오브젝트가 파괴되더라도 코루틴의 실행이 정상적으로 지속될까요?
  - 코루틴은 MonoBehaviour의 StartCoroutine()으로 실행되기 때문에, 해당 MonoBehaviour를 상속받는 오브젝트가 파괴되면
    MonoBehaviour의 소멸과 함께 코루틴도 중단된다.

**확장 문제 : 강의 내용을 바탕으로 새로운 기능을 추가 구현해봅시다.**

<aside>
🙃 **웨이브 10, 30, 50, …**에 부여되는 **랜덤 디버프**를 만들어봅시다.

</aside>

**랜덤 디버프**는 체력을 0%~50%를 감소시키는 무시무시👹한 디버프입니다. 
플레이어의 HP를 실제 감소시키는 것까지 구현해봅시다. (Debug.Log만 하는 것 아님)


### Q3. 심화주차 1-5, 1-6강 ( 스텟 강화 - 플레이어 강화 아이템 구현 )

**확인 문제 : 강의를 듣고, 내용을 다시 점검하는 문제를 풀어봅시다.**

**[🅾️❎퀴즈]**

1. 추상 클래스는 new를 통해 인스턴스화(instantiation)할 수 없다. (O/X)

   O. 추상클래스는 추상화된 메서드라서 구현이 덜 되어있는 클래스입니다. 구현은 상속받는 자식클래스를 통해 구현될 수 있습니다. 따라서 인스턴스화도 부모인 추상클래스가아닌 자식클래스부터 가능합니다.
   
2. 추상 클래스는 다른 클래스처럼 일반 메서드와 속성을 포함할 수 있다. (O/X)

   O. 추상클래스라고 반드시 추상메서드만 가져야하는 것은 아닙니다. 추상클래스도 일반 메서드와 속성을 가질 수 있습니다.
   
3. 추상 클래스를 상속받은 클래스는 추상 클래스의 모든 추상 메서드를 구현해야 한다. (O/X)

   O. 추상클래스의 자식클래스는 존재하는 모든 추상메서드를 구현해야지 사용 할 수 있습니다.
   
4. C#에서 한 클래스는 여러 개의 추상 클래스를 상속받을 수 있다. (O/X)

   X. C#에선 기본적으로 단일상속만 가능하며 다중 상속은 인터페이스만 가능합니다.

**[**🤔 **생각해보기]**

- 추상 클래스를 사용하지 않고 동일한 기능을 구현하려면 어떤 문제가 발생할 수 있는지 설명해보세요.
  - 코드의 재사용성, 유지보수성, 일관성이 크게 저하됩니다. 협업시 기준이되는 추상클래스가 없다면 개발자들이 동일한 기능을 서로 다른 방식으로 설계할 가능성이 커집니다.
  - 여러 클래스에서 동일한 메서드나 속성을 반복적으로 구현하게되니까 한 곳의 변경사항이 다른 곳에 반영되지 않아 오류가 날 확률이 높아집니다.

**개선 문제 : 기존의 코드를 개선해봅시다.**

<aside>
👀 코드리뷰 결과에 따라 코드를 개선해봅시다.

</aside>

당신은 CharacterStatHandler의 코드를 풀리퀘스트했고, 당신의 동료는 아래와 같은 코드리 뷰 결과를 전달했습니다.

> XX님 고생하셨습니다. 아래 내용들에 관련된 코드를 정리해보면 가독성이 높아질 것 같습니다.
> 
> - Awake 메소드 내의 초기화 코드를 분리하는 것이 더 깔끔해보일 것 같습니다.
> - ApplyStatModifiers 메소드 내의 switch식의 코드를 분리하면 가독성이 높아질 것 같습니다.


</div>
</details>


